<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>FPS Mobile - Versão Top</title>
<style>
  :root{--accent:#1f6feb;--danger:#ff4b4b}
  html,body{height:100%;margin:0;background:#06060a;font-family:Inter,Arial,Helvetica,sans-serif;overflow:hidden}
  #canvasWrap{position:fixed;inset:0;display:block;touch-action:none}
  #hud{position:fixed;left:50%;transform:translateX(-50%);top:12px;z-index:999;color:#fff;background:rgba(0,0,0,0.35);padding:8px 14px;border-radius:12px;display:flex;gap:12px;align-items:center;font-weight:600}
  #hud .life{color:#7fffd4}
  #hud .score{color:#ffd86b}
  #cross{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:999;width:18px;height:18px;pointer-events:none}
  #cross:before,#cross:after{content:'';position:absolute;background:rgba(255,255,255,0.9)}
  #cross:before{left:50%;top:0;width:2px;height:100%;transform:translateX(-50%)}
  #cross:after{top:50%;left:0;height:2px;width:100%}
  #shootBtn{position:fixed;right:12px;bottom:18px;width:92px;height:92px;border-radius:50%;background:linear-gradient(145deg,var(--danger),#b00000);border:none;color:white;font-size:18px;z-index:998;box-shadow:0 6px 18px rgba(0,0,0,0.5)}
  #joy{position:fixed;left:12px;bottom:12px;width:140px;height:140px;border-radius:50%;background:rgba(255,255,255,0.04);z-index:998;touch-action:none}
  #stick{width:60px;height:60px;background:linear-gradient(180deg,#fff,#ddd);border-radius:50%;position:absolute;left:40px;top:40px;opacity:0.95;box-shadow:0 6px 18px rgba(0,0,0,0.4)}
  #controlsTop{position:fixed;left:12px;top:12px;z-index:999;display:flex;gap:8px}
  .btnMini{background:rgba(0,0,0,0.35);color:#fff;border:none;padding:8px 10px;border-radius:10px;font-weight:700}
  #menu{position:fixed;right:12px;top:12px;border-radius:12px;background:rgba(0,0,0,0.45);padding:8px;z-index:999}
  #panel{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:1000;background:linear-gradient(180deg,#0b0f1b,#08101b);color:#fff;padding:18px;border-radius:12px;max-width:95%;width:760px;display:none}
  #panel h2{margin:0 0 10px 0}
  #shop .item{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);margin-bottom:8px}
  #startOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.7), rgba(0,0,0,0.85));z-index:2000;flex-direction:column;color:#fff}
  #startOverlay button{padding:14px 22px;border-radius:12px;border:none;background:var(--accent);color:#fff;font-weight:800;font-size:18px}
  small{opacity:0.75}
  /* responsive adjustments */
  @media (max-width:520px){
    #panel{width:94%}
    #joy{width:120px;height:120px}
    #stick{width:52px;height:52px;left:34px;top:34px}
    #shootBtn{width:80px;height:80px}
  }
</style>
</head>
<body>
<div id="canvasWrap"></div>

<div id="hud">
  <div class="life">Vida: <span id="life">100</span></div>
  <div class="score">Pontos: <span id="score">0</span></div>
  <div id="level">Fase: <span id="fase">1</span></div>
</div>

<div id="cross"></div>

<button id="shootBtn">Atirar</button>

<div id="joy"><div id="stick"></div></div>

<div id="controlsTop">
  <button id="btnPause" class="btnMini">Pausar</button>
  <button id="btnShop" class="btnMini">Loja</button>
  <button id="btnRestart" class="btnMini">Reiniciar</button>
</div>

<div id="menu"></div>

<!-- Main modal panel (shop/menus) -->
<div id="panel" aria-hidden="true">
  <h2 id="panelTitle">Loja</h2>
  <div id="panelBody"></div>
  <div style="text-align:right"><button id="closePanel" class="btnMini">Fechar</button></div>
</div>

<!-- Start overlay -->
<div id="startOverlay">
  <h1 style="margin:0 0 10px 0">FPS Mobile — Versão TOP</h1>
  <small>Toque para iniciar. Use o joystick e o botão de tiro. Aperte Loja para upgrades.</small>
  <div style="height:18px"></div>
  <button id="startBtn">INICIAR JOGO</button>
</div>

<!-- THREE.JS -->
<script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.154.0/examples/js/controls/PointerLockControls.js"></script>

<script>
/*
  Jogo FPS Mobile - Versão Top
  - Arma 3D (modelo simples)
  - Sons via WebAudio
  - Inimigos com animações
  - Mapa com prédios
  - Crosshair, fases, loja, corrida, partículas/explosões
  - Joystick e toque mobile
*/

/* -------------------- Config -------------------- */
const CONFIG = {
  PROJECTILE_SPEED: 250,     // units/s
  ENEMY_BASE_SPEED: 8,      // units/s
  ENEMY_COUNT_BASE: 4,
  SPAWN_INTERVAL: 900,      // ms
  PLAYER_MAX_LIFE: 100,
  PLAYER_SPEED: 12,
  PLAYER_SPRINT_MULT: 1.8,
  PARTICLE_COUNT: 18,
  MAX_LEVEL: 8
};

/* -------------------- DOM -------------------- */
const canvasWrap = document.getElementById('canvasWrap');
const lifeEl = document.getElementById('life');
const scoreEl = document.getElementById('score');
const faseEl = document.getElementById('fase');
const shootBtn = document.getElementById('shootBtn');
const joy = document.getElementById('joy');
const stick = document.getElementById('stick');
const startOverlay = document.getElementById('startOverlay');
const startBtn = document.getElementById('startBtn');
const panel = document.getElementById('panel');
const panelTitle = document.getElementById('panelTitle');
const panelBody = document.getElementById('panelBody');
const closePanel = document.getElementById('closePanel');
const btnShop = document.getElementById('btnShop');
const btnPause = document.getElementById('btnPause');
const btnRestart = document.getElementById('btnRestart');

/* -------------------- Three.js setup -------------------- */
let scene, camera, renderer, controls;
let clock = new THREE.Clock();
let player = { life: CONFIG.PLAYER_MAX_LIFE, speed: CONFIG.PLAYER_SPEED, sprint:false };
let score = 0;
let level = 1;
let running = false, paused = false;
let enemies = [], projectiles = [], particles = [];
let mapObjects = [];
let lastSpawn = 0;

/* ---------- audio (WebAudio procedural samples) ---------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();

function playShoot(){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'square';
  o.frequency.value = 900 + Math.random()*200;
  g.gain.value = 0.02;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  o.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.12);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.12);
  o.stop(audioCtx.currentTime + 0.13);
}
function playHit(){
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type='sawtooth'; o.frequency.value = 200 + Math.random()*200;
  g.gain.value = 0.04; o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.25);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.25);
  o.stop(audioCtx.currentTime + 0.26);
}
function playExplode(){
  const o1 = audioCtx.createOscillator(), o2 = audioCtx.createOscillator(); const g=audioCtx.createGain();
  o1.type='triangle'; o2.type='square';
  o1.frequency.value=400; o2.frequency.value=200;
  g.gain.value=0.06;
  o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
  o1.start(); o2.start();
  o1.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime+0.5);
  o2.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime+0.5);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.5);
  o1.stop(audioCtx.currentTime+0.52); o2.stop(audioCtx.currentTime+0.52);
}

/* -------------------- init Scene -------------------- */
function initThree(){
  scene = new THREE.Scene(); scene.background = new THREE.Color(0x071124);
  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  canvasWrap.appendChild(renderer.domElement);

  // lighting
  const hemi = new THREE.HemisphereLight(0xeeeeff, 0x222233, 0.7); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(-10,20,10); scene.add(dir);

  // ground
  const groundMat = new THREE.MeshStandardMaterial({color:0x0d1630, roughness:0.9});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(400,400), groundMat);
  ground.rotation.x = -Math.PI/2; ground.position.y=0; scene.add(ground);

  // camera / player start
  camera.position.set(0,1.6,6);

  // simple skybox-ish gradient using fog
  scene.fog = new THREE.FogExp2(0x071124, 0.01);

  window.addEventListener('resize', onResize);
}

/* -------------------- weapon model (simple 3D) -------------------- */
function createWeapon(){
  const group = new THREE.Group();
  // body
  const bodyMat = new THREE.MeshStandardMaterial({color:0x222a3a, metalness:0.6, roughness:0.4});
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.18,1.4), bodyMat); body.position.set(0,-0.15,-0.35); group.add(body);
  // magazine
  const mag = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.5,0.5), new THREE.MeshStandardMaterial({color:0x111122}));
  mag.position.set(0.2,-0.4,-0.1); mag.rotation.x = 0.08; group.add(mag);
  // barrel
  const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.9,12), new THREE.MeshStandardMaterial({color:0x666})); 
  barrel.rotation.z = Math.PI/2; barrel.position.set(0,-0.12,-1.1); group.add(barrel);
  // sight
  const sight = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.05,0.15), new THREE.MeshStandardMaterial({color:0x99d}));
  sight.position.set(0,-0.05,-0.55); group.add(sight);
  // small flash point
  const flash = new THREE.Mesh(new THREE.SphereGeometry(0.03,6,6), new THREE.MeshStandardMaterial({emissive:0xffdba3, emissiveIntensity:1}));
  flash.position.set(0,-0.12,-1.6); group.add(flash);

  return group;
}

/* -------------------- enemy creation -------------------- */
function spawnEnemy(){
  const geo = new THREE.BoxGeometry(1.0,1.6,0.8);
  const mat = new THREE.MeshStandardMaterial({color:0xcc4455, metalness:0.1, roughness:0.8});
  const mesh = new THREE.Mesh(geo, mat);
  const angle = Math.random()*Math.PI*2;
  const r = 25 + Math.random()*18;
  mesh.position.set(Math.cos(angle)*r, 0.8, Math.sin(angle)*r);
  mesh.userData = {hp: 2 + Math.floor(level/2), speed: CONFIG.ENEMY_BASE_SPEED + Math.random()*3 + level*0.6, bob: Math.random()*1000};
  scene.add(mesh);
  enemies.push(mesh);
}

/* -------------------- map (buildings/obstacles) -------------------- */
function buildMap(){
  // clear old
  mapObjects.forEach(m=>scene.remove(m)); mapObjects = [];

  // a few buildings boxes
  for(let i=0;i<12;i++){
    const w = 3 + Math.random()*8;
    const h = 2 + Math.random()*12;
    const d = 3 + Math.random()*8;
    const mat = new THREE.MeshStandardMaterial({color: 0x111a2a + Math.floor(Math.random()*0x002244), roughness: 0.9});
    const b = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
    const angle = Math.random()*Math.PI*2; const dist = 8 + Math.random()*60;
    b.position.set(Math.cos(angle)*dist, h/2 - 0.1, Math.sin(angle)*dist);
    b.rotation.y = Math.random()*Math.PI*2;
    scene.add(b); mapObjects.push(b);
    // small rooftop details
    if(Math.random()>0.6){
      const deco = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.4,0.8), new THREE.MeshStandardMaterial({color:0x444866}));
      deco.position.set(b.position.x, b.position.y + h/2 + 0.2, b.position.z);
      scene.add(deco); mapObjects.push(deco);
    }
  }
  // add some low cover objects
  for(let i=0;i<20;i++){
    const w=1+Math.random()*3, d=1+Math.random()*3, h=0.6;
    const mat = new THREE.MeshStandardMaterial({color:0x223344});
    const o = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
    const angle = Math.random()*Math.PI*2; const dist = 6 + Math.random()*40;
    o.position.set(Math.cos(angle)*dist, h/2, Math.sin(angle)*dist);
    o.rotation.y = Math.random()*Math.PI;
    scene.add(o); mapObjects.push(o);
  }
}

/* -------------------- particles / explosion -------------------- */
function spawnExplosion(pos){
  for(let i=0;i<CONFIG.PARTICLE_COUNT;i++){
    const p = new THREE.Mesh(new THREE.SphereGeometry(0.06,6,6), new THREE.MeshStandardMaterial({color:0xffaa33, emissive:0xff7744, emissiveIntensity:1}));
    p.position.copy(pos);
    p.userData = {vel: new THREE.Vector3((Math.random()-0.5)*6, Math.random()*4, (Math.random()-0.5)*6), life: 0.8 + Math.random()*0.6};
    scene.add(p); particles.push(p);
  }
}

/* -------------------- projectiles -------------------- */
function fireProjectile(){
  // weapon recoil/vibration
  playShoot();
  const pGeo = new THREE.SphereGeometry(0.06,8,8);
  const pMat = new THREE.MeshStandardMaterial({color:0xfff4b0, emissive:0xffffcc, emissiveIntensity:1});
  const proj = new THREE.Mesh(pGeo, pMat);
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  proj.position.copy(camera.position).add(dir.clone().multiplyScalar(1.6));
  proj.userData = {vel: dir.clone().multiplyScalar(CONFIG.PROJECTILE_SPEED*0.5), life: 3};
  scene.add(proj); projectiles.push(proj);
  // small muzzle flash particle
  const muzzle = new THREE.Mesh(new THREE.SphereGeometry(0.06,6,6), new THREE.MeshStandardMaterial({emissive:0xffddaa, emissiveIntensity:1}));
  muzzle.position.copy(proj.position);
  scene.add(muzzle);
  setTimeout(()=>scene.remove(muzzle), 80);
}

/* -------------------- collisions & updates -------------------- */
function updateAll(dt){
  // projectiles
  for(let i = projectiles.length-1; i>=0; i--){
    const p = projectiles[i]; p.userData.life -= dt;
    p.position.addScaledVector(p.userData.vel, dt);
    // check collision with enemies
    for(let j = enemies.length-1; j>=0; j--){
      const e = enemies[j];
      if(e.position.distanceTo(p.position) < 1.0){
        // hit
        e.userData.hp -= 1;
        playHit();
        // remove projectile
        scene.remove(p); projectiles.splice(i,1); break;
      }
    }
    if(p && p.userData.life <= 0){
      scene.remove(p); projectiles.splice(i,1);
    }
  }

  // enemies move toward player
  const playerPos = camera.position;
  for(let i = enemies.length-1; i>=0; i--){
    const e = enemies[i];
    // bobbing animation
    e.position.y = 0.8 + Math.sin((performance.now()+e.userData.bob)*0.004)*0.08;
    const dir = playerPos.clone().sub(e.position); dir.y = 0; dir.normalize();
    const speed = e.userData.speed * (1 + Math.sin(performance.now()*0.001)*0.05);
    e.position.addScaledVector(dir, speed * dt);

    // if touches player
    if(e.position.distanceTo(playerPos) < 1.2){
      player.life -= 15 * dt; // damage over time
      if(player.life <= 0 && running){
        player.life = 0; endGame();
      }
    }

    // enemy death
    if(e.userData.hp <= 0){
      score += 10;
      scoreEl.textContent = score;
      spawnExplosion(e.position.clone());
      playExplode();
      scene.remove(e); enemies.splice(i,1);
    }
  }

  // particles update
  for(let i = particles.length-1; i>=0; i--){
    const p = particles[i];
    p.userData.life -= dt;
    p.position.addScaledVector(p.userData.vel, dt);
    p.material.opacity = Math.max(0, p.userData.life/1.2);
    if(p.userData.life <= 0){
      scene.remove(p); particles.splice(i,1);
    }
  }

  // check spawn timing
  const now = performance.now();
  if(now - lastSpawn > CONFIG.SPAWN_INTERVAL && enemies.length < CONFIG.ENEMY_COUNT_BASE + level*2){
    spawnEnemy(); lastSpawn = now;
  }
}

/* -------------------- rendering loop -------------------- */
let prevTime = performance.now();
function animate(){
  const now = performance.now();
  const dt = Math.min(0.05, (now - prevTime) / 1000);
  prevTime = now;
  if(running && !paused){
    // movement from joystick (moveX, moveZ)
    const moveSpeed = player.speed * (player.sprint ? CONFIG.PLAYER_SPRINT_MULT : 1);
    const moveVec = new THREE.Vector3(moveX, 0, moveZ).normalize().applyQuaternion(camera.quaternion);
    moveVec.y = 0; camera.position.addScaledVector(moveVec, moveSpeed * dt);

    updateAll(dt);
    // level progression: if all enemies cleared and score threshold reached, next level
    if(enemies.length === 0 && score >= level * 50 && level < CONFIG.MAX_LEVEL){
      level++; faseEl.textContent = level;
      CONFIG.SPAWN_INTERVAL = Math.max(350, CONFIG.SPAWN_INTERVAL - 60);
      // small reward
      player.life = Math.min(CONFIG.PLAYER_MAX_LIFE, player.life + 20);
      buildMap();
    }
  }
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

/* -------------------- controls (touch joystick & shoot) -------------------- */
let touching = false, startX=0, startY=0, moveX=0, moveZ=0;

joy.addEventListener('touchstart', e=>{
  e.preventDefault();
  touching = true;
  startX = e.touches[0].clientX; startY = e.touches[0].clientY;
});
joy.addEventListener('touchmove', e=>{
  if(!touching) return;
  const dx = e.touches[0].clientX - startX;
  const dy = e.touches[0].clientY - startY;
  const max = 44;
  const sx = Math.max(-max, Math.min(max, dx));
  const sy = Math.max(-max, Math.min(max, dy));
  stick.style.left = 40 + sx + 'px';
  stick.style.top = 40 + sy + 'px';
  // map to moveX/moveZ (forward/backwards reversed)
  moveX = sx / max; moveZ = sy / max * -1;
});
joy.addEventListener('touchend', e=>{
  touching = false; stick.style.left = '40px'; stick.style.top = '40px'; moveX = 0; moveZ = 0;
});

// shoot button handlers
shootBtn.addEventListener('touchstart', e=>{ e.preventDefault(); fireProjectile(); });
shootBtn.addEventListener('mousedown', e=>{ fireProjectile(); });

// allow keyboard for desktop debugging
window.addEventListener('keydown', e=>{
  if(e.code === 'Space') fireProjectile();
  if(e.key === 'Shift') player.sprint = true;
});
window.addEventListener('keyup', e=>{ if(e.key === 'Shift') player.sprint = false; });

/* -------------------- shop & upgrades -------------------- */
let playerData = { coins: 0, weaponLevel: 1, unlocked:true };
const ITEMS = [
  { id:'hp', name:'+20 Vida', price: 30, apply: ()=>{ player.life = Math.min(CONFIG.PLAYER_MAX_LIFE, player.life + 20); } },
  { id:'weapon1', name:'Melhor Munição (+dano)', price: 80, apply: ()=>{ CONFIG.PROJECTILE_SPEED += 60; } },
  { id:'speed', name:'Correr mais (+velocidade)', price: 100, apply: ()=>{ player.speed += 3; } },
  { id:'maxhp', name:'+10 Vida Máx', price: 150, apply: ()=>{ CONFIG.PLAYER_MAX_LIFE += 10; player.life += 10; } }
];

function openShop(){
  panelTitle.textContent = 'Loja';
  panelBody.innerHTML = '';
  ITEMS.forEach(it=>{
    const div = document.createElement('div'); div.className='item';
    div.innerHTML = `<div><strong>${it.name}</strong><div style="opacity:.7">Preço: ${it.price}</div></div><div><button class="btnMini" data-id="${it.id}">Comprar</button></div>`;
    panelBody.appendChild(div);
  });
  panel.style.display = 'block';
  panel.setAttribute('aria-hidden', 'false');
}
closePanel.addEventListener('click', ()=>{ panel.style.display='none'; panel.setAttribute('aria-hidden','true'); });
btnShop.addEventListener('click', openShop);
panelBody.addEventListener('click', (e)=>{
  const btn = e.target.closest('button');
  if(!btn) return;
  const id = btn.dataset.id;
  const it = ITEMS.find(x=>x.id===id);
  if(!it) return;
  if(playerData.coins >= it.price){
    playerData.coins -= it.price; it.apply(); alert('Comprado: '+it.name);
  } else {
    alert('Sem coins suficientes!');
  }
});

/* -------------------- UI controls -------------------- */
btnPause.addEventListener('click', ()=>{ paused = !paused; btnPause.textContent = paused ? 'Retomar' : 'Pausar'; });
btnRestart.addEventListener('click', ()=>{ location.reload(); });

/* -------------------- start / end flow -------------------- */
function startGameFlow(){
  // resume audio context for mobile autoplay rules
  if(audioCtx.state === 'suspended') audioCtx.resume();
  startOverlay.style.display = 'none';
  running = true; paused = false;
  initThree();
  createInitialWorld();
  animate();
}

startBtn.addEventListener('click', startGameFlow);

/* -------------------- create initial world and HUD -------------------- */
let weaponMesh;
function createInitialWorld(){
  // weapon
  weaponMesh = createWeapon(); scene.add(weaponMesh);
  weaponMesh.position.set(0,-0.35,-0.8); weaponMesh.rotation.x = 0.02;

  // initial enemies
  for(let i=0;i<CONFIG.ENEMY_COUNT_BASE + level;i++) spawnEnemy();
  buildMap();

  // show HUD initial
  lifeEl.textContent = Math.floor(player.life);
  scoreEl.textContent = score;
  faseEl.textContent = level;

  lastSpawn = performance.now() + 500;
}

/* -------------------- camera look follow (simple pseudo-recoil) -------------------- */
function updateWeapon(){ // keep weapon positioned relative to camera
  if(!weaponMesh) return;
  // weapon follows camera orientation smoothly
  const camQuat = camera.quaternion;
  const offset = new THREE.Vector3(0,-0.3,-0.7).applyQuaternion(camQuat);
  weaponMesh.position.copy(camera.position.clone().add(offset));
  weaponMesh.quaternion.slerp(camQuat, 0.2);
}

/* -------------------- general loop tie-in -------------------- */
(function mainLoop(){
  (function loop(){
    if(running && !paused){
      // small updates that depend on time
      const delta = clock.getDelta();
      // animate weapon bobbing when moving
      updateWeapon();
      // update HUD
      lifeEl.textContent = Math.max(0, Math.floor(player.life));
      scoreEl.textContent = score;
      // update movement values from virtual joystick mapping
      // moveX, moveZ are set by joy handlers (global)
      // apply sprint
      player.sprint = isSprinting;
    }
    requestAnimationFrame(loop);
  })();
})();

/* -------------------- small helpers -------------------- */
function endGame(){
  running = false;
  alert(`Game Over! Pontos: ${score}`);
  // show panel with restart
  panelTitle.textContent = 'Game Over';
  panelBody.innerHTML = `<div style="padding:12px">Pontos: ${score}<br><br><button id="toRestart" class="btnMini">Jogar Novamente</button></div>`;
  panel.style.display = 'block';
  document.getElementById('toRestart').addEventListener('click', ()=>location.reload());
}

/* -------------------- mobile sprint toggle (double-tap on joy) -------------------- */
let lastTap = 0; let isSprinting = false;
joy.addEventListener('touchend', ()=>{
  const now = Date.now();
  if(now - lastTap < 300){ isSprinting = !isSprinting; navigator.vibrate?.(40); }
  lastTap = now;
});

/* -------------------- hooking into animate() and rendering -------------------- */
/* We had animate() defined earlier that calls renderer and updateAll. To tie updateWeapon and UI updates,
   we will replace animate with a wrapper that includes them. */
prevTime = performance.now();
function mainAnimate(){
  const now = performance.now();
  const dt = Math.min(0.06, (now - prevTime) / 1000);
  prevTime = now;
  if(running && !paused){
    // joystick movement uses moveX/moveZ mapped earlier
    const moveSpeed = player.speed * (player.sprint ? CONFIG.PLAYER_SPRINT_MULT : 1);
    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).setY(0).normalize();
    const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion).setY(0).normalize();
    const moveVec = forward.clone().multiplyScalar(moveZ).add(right.clone().multiplyScalar(moveX));
    if(moveVec.lengthSq() > 0.0001) camera.position.addScaledVector(moveVec.normalize(), moveSpeed * dt);
    // weapon follow
    updateWeapon();
    // update world
    updateAll(dt);
    lifeEl.textContent = Math.floor(player.life);
    scoreEl.textContent = score;
    faseEl.textContent = level;
  }
  renderer.render(scene, camera);
  requestAnimationFrame(mainAnimate);
}

/* Replace earlier animate with this */
animate = mainAnimate;

/* ensure window resize handled */
function onResize(){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }

/* -------------------- enable pointer lock & mouse look for desktop use -------------------- */
const pointerLockControls = new THREE.PointerLockControls(camera, document.body);
document.addEventListener('click', ()=>{ try{ pointerLockControls.lock(); }catch(e){} });
pointerLockControls.addEventListener('lock', ()=>{ /* locked */ });
pointerLockControls.addEventListener('unlock', ()=>{ /* unlocked */ });
scene?.add(pointerLockControls.getObject());

/* -------------------- initialization safe-call (create scene early but start only on click) -------------------- */
initThree(); // create renderer and scene; will be reused on startFlow
// Remove auto-started render loop; the real loop starts when startGameFlow called
renderer.render(scene, camera);

/* -------------------- utilities tie-ups -------------------- */
function createWeapon(){ // shorter recreate for beginning
  return createWeaponModel();
}

/* createWeaponModel returns a THREE.Group; define it here to avoid hoisting issues */
function createWeaponModel(){
  const group = new THREE.Group();
  const bodyMat = new THREE.MeshStandardMaterial({color:0x2b3140, metalness:0.6, roughness:0.35});
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.18,1.4), bodyMat); body.position.set(0,-0.15,-0.35);
  group.add(body);
  const mag = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.5,0.5), new THREE.MeshStandardMaterial({color:0x0f1724}));
  mag.position.set(0.18,-0.4,-0.1); group.add(mag);
  const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.9,12), new THREE.MeshStandardMaterial({color:0x616b76}));
  barrel.rotation.z = Math.PI/2; barrel.position.set(0,-0.12,-1.1); group.add(barrel);
  const sight = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.05,0.15), new THREE.MeshStandardMaterial({color:0x6fb6ff}));
  sight.position.set(0,-0.05,-0.55); group.add(sight);
  const flash = new THREE.Mesh(new THREE.SphereGeometry(0.03,6,6), new THREE.MeshStandardMaterial({emissive:0xffdba3, emissiveIntensity:1}));
  flash.position.set(0,-0.12,-1.6); group.add(flash);
  return group;
}

/* small helper to call fireProjectile and animate muzzle recoil */
function fireProjectile(){
  fireProjectileInternal();
  // camera recoil small
  const recoil = 0.05;
  camera.rotation.x = Math.max(-0.3, camera.rotation.x - recoil*0.6);
  setTimeout(()=>{ camera.rotation.x += recoil*0.6; }, 80);
}

/* actual function defined earlier as fireProjectile; rename to avoid double def issues */
function fireProjectileInternal(){
  playShoot();
  const pGeo = new THREE.SphereGeometry(0.06,8,8);
  const pMat = new THREE.MeshStandardMaterial({color:0xfff4b0, emissive:0xffffcc, emissiveIntensity:1});
  const proj = new THREE.Mesh(pGeo, pMat);
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  proj.position.copy(camera.position).add(dir.clone().multiplyScalar(1.6));
  proj.userData = {vel: dir.clone().multiplyScalar(CONFIG.PROJECTILE_SPEED*0.8), life: 3};
  scene.add(proj); projectiles.push(proj);
  const muzzle = new THREE.Mesh(new THREE.SphereGeometry(0.06,6,6), new THREE.MeshStandardMaterial({emissive:0xffddaa, emissiveIntensity:1}));
  muzzle.position.copy(proj.position);
  scene.add(muzzle);
  setTimeout(()=>scene.remove(muzzle), 80);
}

/* expose some debug helpers globally (for advanced tweaks) */
window.__game = { scene, camera, renderer, spawnEnemy, spawnExplosion, playerData };

/* final: start main animation loop when player actually starts */
startBtn.addEventListener('click', ()=>{
  if(audioCtx.state === 'suspended') audioCtx.resume();
  startOverlay.style.display = 'none';
  if(!running){
    // re-init scene if necessary
    if(!scene) initThree();
    // weapon
    weaponMesh = createWeaponModel();
    scene.add(weaponMesh);
    // initial enemies and map
    for(let i=0;i<CONFIG.ENEMY_COUNT_BASE + level;i++) spawnEnemy();
    buildMap();
    running = true; paused = false;
    prevTime = performance.now();
    mainAnimate();
  }
});

/* ensure initial instructions visible when loaded */
startOverlay.style.display = 'flex';

</script>
</body>
</html>
